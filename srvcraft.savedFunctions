#!/bin/bash

# work only on linux
wget=/usr/bin/wget


############
## COLORS ##
############
nocolor='\033[0m'
white='\e[0;97m'
whitebold='\e[0;1;97m'
purple='\033[0;38;5;201m'
blue='\033[0;38;5;45m'
darkblue='\033[0;38;5;27m'
green='\033[0;32m'
greendim='\033[0;3;32m'
yellow='\033[0;38;5;178m'
orange='\e[0;3;38;5;166m'
gray='\033[0;38;5;249m'
graybold='\033[0;1;38;5;249m'
graydim='\033[0;2;38;5;250m'
red='\033[0;91m'
## CUSTOM
c__functionName='\033[0;38;5;45m'



##################
## GLOBALS VARS ##
# true is shell command and always return 0 
# false always return 1
##################

g_serversDIR="./instances"
g_loaderDIR="./loader"

## PRINT
g_isVerboseActive="true"
g_isDoubleVerboseActive="false"

# list of availables versions and its download URL, in order (check https://mcversions.net for update)
declare -a g_versionsList=(
    "1.19.3"
    "1.19.2"
    "1.19"
)
declare -a g_versionsURLList=(
    "https://piston-data.mojang.com/v1/objects/c9df48efed58511cdd0213c56b9013a7b5c9ac1f/server.jar"
    "https://piston-data.mojang.com/v1/objects/f69c284232d7c7580bd89a5a4931c3581eae1378/server.jar"
)
# Associative array of property name and his value
declare -A ga_loaderServerProperties




##########
## HELPERS ##
##########

StartText () {
    printf "\n${blue}This script is made for generate a READY-TO-USE minecraft server.
Follow the next steps to deploy your server !${nocolor}\n"
printf "${gray}Availables versions :
  1.19 -> 1.19.3
  1.18 -> 1.18.2
${nocolor}"
}
HowToUse () {
    printf "\n${gray}Server Manager - create, deploy and clear your minecraft server instances
    srvmng [ -i | --install   : download and install command ]
           [ -l | --list   : list all instances ]
           [ -s | --start  : start a server ]
           [ -d | --deploy : create and deploy a server ]
           [ --config      : config properties of based server.properties file ]
           [ --clear       : clear all the instances ]
${graydim}See https://github.com/alexiscotel/minecraftserver/README.md for more explainations${nocolor}
\n"
}



###############
## FUNCTIONS ##
###############

# @Function : List all lines from a directory with regex filter (arg 2)
# @Params
#   $1 repository
# @LastMessage: "Start clonning"
# UseCase : CloneRepo
CloneRepo () {
    repo=$1
    repoDir="tmp"

    printf "${gray}Start cloning repository ...${nocolor}\n"
    ClearDir $repoDir    
    mkdir $repoDir

    printf "${graydim}"
    git clone git@github.com:alexiscotel/minecraftserver.git $repoDir
    printf "\n${nocolor}"
}

# @Function : Check if srvmng needed files are presents
# @Result : update CheckIfCmdInstall var
# @LastMessage: "already installed" or "no install found"
# @UseCase : CheckIfCmdInstall
CheckCmdInstalled () {
    CheckIfCmdInstall="false"
    
    if [ -d "instances" ]; then
        printf "${yellow}Server Manager is already installed${nocolor}\n"

        if [ -n "$forceInstall" ]; then
            # printf "\n${gray}Force reinstallation${nocolor}"
            CheckIfCmdInstall="true"
        else
            # printf "${gray}Skip install.${nocolor}"
            CheckIfCmdInstall="false"
        fi
    else
        printf "\n${orange}No install found. ${nocolor}"
        CheckIfCmdInstall="true"
    fi
}


# @Function : Read loader server.properties file and put in an associative array
# @Params
#  - $1 directory (optional)
# @Return g_loaderServerProperties
# @UseCase : 
#  - LoadServerPropertiesFile "path/to/server.properties"
#  - if [ "$LoadServerPropertiesFile_status" == "true" ]; then echo "Job failed" else echo "Job done" fi
LoadServerPropertiesFile () {
    LoadServerPropertiesFile_failed="false"
    sourceFile=$1

    if [ "$g_isVerboseActive" == "true" ]; then
        printf "${c__functionName} > LoadServerPropertiesFile ${nocolor}\n"
    fi

    # test if param is empty
    if [ -z "$sourceFile" ]; then
        sourceFile="${g_loaderDIR}/server.properties"
    fi # endof if param is empty

    # test if file exists
    if [ ! -f "$sourceFile" ]; then
        # file not exists - update status value
        LoadServerPropertiesFile_failed="true"
    else
        IFS='='
        while IFS= read -r line
        do
            if [ -n "${line}" ]; then
                hastag=${line:0:1}

                if [ "${hastag}" != "#" ]; then
                    read -a strarr <<< "$line"
                    key="${strarr[0]}"
                    value="${strarr[1]}"

                    ga_loaderServerProperties["${key}"]="${value}"

                    if [ "$g_isDoubleVerboseActive" == "true" ] ; then
                        printf "${graydim}  > ${key} =${gray} ${value} ${nocolor}\n"
                    fi
                fi
            fi
        done <"$sourceFile"
    fi # endof if file exists
}
# @Function : list items of g_versionsList
# @UseCase : 
#  - ListServerProperties
ListServerProperties () {
    local cpt=0
    printf "${gray}List of${whitebold} Versions ${nocolor}\n${gray}"
    for version in ${g_versionsList[@]}; do
        cpt=$((cpt+1))
        printf "${version}" 
        if ! exists $version in $g_versionsList; then printf " ${yellow}No URL"; fi
        printf "${nocolor}\n"
    done
}
# @Function : List availables versions
# UseCase : ListAvailablesVersions
ListAvailablesVersions () {
    local cpt=0
    printf "${gray}List of${whitebold} Versions ${nocolor}\n${gray}"
    for version in ${g_versionsList[@]}; do
        cpt=$((cpt+1))
        printf "${version}" 
        if ! exists $version in $g_versionsList; then printf " ${yellow}No URL"; fi
        printf "${nocolor}\n"
    done
}

# @Function : List all items from a directory with regex filter (arg 2)
# @Params
#   $1 directory
#   $2 filter regex
# @LastMessage: Total of items
# UseCase : ListDir "path/to/dir" ".*"
ListDir () {
    dir=$1

    if [ "$dir" == "*" ]; then
        dirbasename=$1
        listarray=$(find $dir -maxdepth 1)
    fi
    if [ "$dir" != "*" ]; then 
        dirbasename="$(basename -- $dir)"
        listarray=$(find $dir/* -maxdepth 1)
    fi

    excludeRegex=$2
    col=$3

    if [ -z "$2" ]; then
        if [ "$dir" == "*" ]; then
            listarray=$(find $dir -maxdepth 1)
        fi
        if [ "$dir" != "*" ]; then 
            listarray=$(find $dir/* -maxdepth 1)
        fi
    else
        if [ "$dir" == "*" ]; then 
            listarray=$(find $dir -maxdepth 1 ! -name \'$excludeRegex\')
        fi
        if [ "$dir" != "*" ]; then
            listarray=$(find $dir/* -maxdepth 1 ! -name \'$excludeRegex\')
        fi
    fi
    if [ -z "$3" ] ; then
        col=false
    else
        col=$3
    fi

    printf "${gray}List of${whitebold} ${dirbasename} ${nocolor}\n"
    cpt=0
    if test $col == "false"; then
        printf "  "
    fi
    printf "${gray}"
    for line in $listarray; do
        f="$(basename -- $line)"
        if [[ -d $f ]]; then
            cpt=$((cpt+1))
            printf "${darkblue}"
            printf "${f} ${nocolor}"
            if test $col == "true"; then
                printf "\n"
            fi
        elif [[ -f $f ]]; then
            cpt=$((cpt+1))
            printf "${white}"
            printf "${f} ${nocolor}"
            if test $col == "true"; then
                printf "\n"
            fi
        fi
    done
    printf "\n${nocolor}"
    printf "${graydim}TOTAL :${whitebold} $cpt ${nocolor}\n"
}
# @Function : Create dir passed in parameter
# @Params
#   $1 directory
# @LastMessage: "exist" or "completed" or "error"
# UseCase : CreateDir "instances"
CreateDir () {
    dir=$1
    printf "${gray}create dir${white} \"${dir}\" ${nocolor}... "
    if [ ! -d "$dir" ]; then
        mkdir "${dir}"
        if [ -d "$dir" ]; then
            printf "${greendim} complete${nocolor}\n"
        else
            printf "${red} error${nocolor}\n"
            exit 0
        fi
    else
        printf " ${yellow}allready exists. ${nocolor}\n"
    fi
}
# @Function : Remove dir passed in parameter
# @Params
#   $1 directory
# @LastMessage: "completed" or "error"
# UseCase : ClearDir "path/to/dir"
ClearDir () {
    dir=$1
    if [ -d "$dir" ]; then
        printf "${gray}Start removing${white} ${dir} ${gray}...${nocolor} "
        printf "${red}"
        rm -rf $dir
        printf "${nocolor}"

        if [ ! -d "$dir" ]; then
            printf "${green} with success${nocolor}\n"
        else
            printf "${red} with error. dir${white} ${dir} ${red}still exists${nocolor}\n"
        fi
    fi
}

# @Function : Copy file passed from parameter
# @Params
#   $1 path file source
#   $1 path file destination
# @LastMessage: "completed" or "error"
# @UseCase : CopyFile "path/to/source" "path/to/destination"
CopyFile () {
    file=$1
    fileDir=$2

    printf "${gray}create file${white} ${fileDir}/${file} ${nocolor}... "

    if [ ! -d "${fileDir}" ]; then
        printf "${yellow}dir not found.${nocolor}\n"
        exit 0
    fi
    
    if [ ! -f "${fileDir}/${file}" ]; then
        printf "${yellow}file not found. ${gray}Start copy ... ${nocolor} "
        printf "${red}"
        cp -r "tmp/${fileDir}/${file}" "${fileDir}/${file}"
        printf "${nocolor}"
        
        if [ ! -f "${fileDir}/${file}" ]; then
            # error
            printf "${red}with failed, \"${fileDir}/${file}\" not found.${nocolor}\n"
            exit 0
        else
            # good
            printf "${greendim}with success.${nocolor}\n"
        fi
    else
        printf " ${yellow}allready exists. ${nocolor}\n"
    fi
}


#####################
## ASKED QUESTIONS ##
#####################

# @Function : Ask for server to use
# @Result : vars $selectedServer available
# @UseCase : 
# - SelectServer
# - if [ "$SelectServer_failed" == "true" ]; then echo "instances/ dir not exists" else echo "server selected : $selectedServer" fi
SelectServer () {
    SelectServer_failed="false"
    selectedServer=""

    # test if servers dir exists
    if [ ! -d "$g_serversDIR" ]; then
        SelectServer_failed="true"

        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${red}servers directory \"${g_serversDIR}\" does not exits${nocolor}\n"
            exit 1
        fi
    else
        i=0
        while read line; do
            serversList[ $i ]="$line"        
            (( i++ ))
        done < <(ls -ACDtu1 "../instances")

        printf "${gray}"
        PS3='Select value in the list : '
        select opt in "${serversList[@]}"; do
            case "$opt" in
                "") continue ;;
                *)
                    printf "${nocolor}"
                    selectedServer=$opt
                    break
                    ;;
            esac
        done

        echo $selectedServer
    fi
}

# @Function : Ask for version to use
# @Result : var versionUsed available
# @UseCase : SelectForVersion
SelectForVersion () {
    SelectForVersion_failed="false"
    versionUsed=""

    # printf "\n${whitebold}Select Version${nocolor}\n"
    PS3='Select version : '
    select v in "${g_versionsList[@]}"; do
        case "$v" in
            "") continue ;;
            *)
                versionUsed=$v
                break
                ;;
        esac
    done

    if [ -z "$versionUsed" ]; then
        SelectForVersion_failed="true"
    else
        if [ "$g_isVerboseActive" == "true" ] ; then
            printf "${gray}Selected version :${green} ${versionUsed} ${nocolor}\n"
        fi
    fi
}

# @Function : Ask for server name
# @Result : vars $serverFullName & $serverName availables
# @UseCase : AskForServerName
AskForServerName () {
    serverFullName=""
    serverName=""

    printf "\n${whitebold}Minecraft server name${nocolor}\n"
    
    while true; do
        read -p $'\033[0;32m  Choose a name for your server :\033[0m ' serverFullName

        if [ -z "$serverFullName" ]; then
            printf "${red}DB name can't be empty${nocolor}\n"
            continue
        fi
        break
    done

    serverName="${serverFullName// /-}"
    if [ ! -n "${serverName}" ]; then
        serverName="${defaultserverfullname// /-}"
    fi
    
    if [ "$g_isVerboseActive" == "true" ] ; then
        printf "${gray}server name :${green} ${serverFullName} ${graydim}(${serverName})${nocolor}\n"
    fi
}

# @Function : select server property (used for editing)
# @Result : vars $selectedProperty available
# @UseCase : 
# - SelectProperty
# - if [ "$SelectProperty_failed" == "true" ]; then echo "Property empty" else echo "property found $selectedProperty" fi
SelectProperty () {
    SelectProperty_failed="false"
    selectedProperty=""

    # printf "\n${whitebold}Select Property${nocolor}\n"
    PS3='Select property : '
    select p in ${!ga_loaderServerProperties[@]}; do
        case "$p" in
            "") continue ;;
            *)
                selectedProperty=$p
                break
                ;;
        esac
    done

    if [ -z "$selectedProperty" ]; then
        SelectProperty_failed="true"
    else
        if [ "$g_isVerboseActive" == "true" ] ; then
            printf "${gray}Selected version :${green} ${selectedProperty} ${nocolor}\n"
        fi
    fi
}

# @Function : Ask for value to assign to the property passed in param
# @Result : vars $propertyValue available
# @UseCase : 
# - AskForPropertyValue
# - if [ "$AskForPropertyValue_failed" == "true" ]; then echo "Property can't be edited" else echo "value assigned (retreive with $propertyValue)" fi
AskForPropertyValue () {
    AskForPropertyValue_failed="false"
    property=$1

    # test if param is empty
    if [ -z "$property" ]; then
        AskForPropertyValue_failed="true"

        if [ "$g_isVerboseActive" == "true" ] ; then
            printf "${red}property param is empty${nocolor}"
        fi
    fi # endof if param is empty

    propertyValueType=${ga_ServerPropertiesAllowValues[$property]}
    case $propertyValueType in
        boolean)
            printf "${gray}"
            PS3='Select: '
            selectOpts=("true" "false")
            select opt in "${selectOpts[@]}"
            do
                case $opt in
                    "true")
                        printf "${nocolor}"
                        propertyValue="true"
                        break
                        ;;
                    "false")
                        printf "${nocolor}"
                        propertyValue="false"
                        break
                        ;;
                    *) 
                        printf "${nocolor}"
                        printf "${red}invalid option $REPLY ${nocolor}"
                        continue
                    ;;
                esac
            done
            
        ;;

        number)
            while true; do
                promptTextColor=$'\033[0;32m'
                promptNoColor=$'\033[0m'
                valueColor=$'\033[0;38;5;45m'
                read -e -p "$promptNoColor Choose a numeric value for property ${promptTextColor}${property}${promptNoColor} : ${valueColor}" propertyValue
                printf "${nocolor}"

                if [ -z "$propertyValue" ]; then
                    printf "${red}Value can't be empty${nocolor}\n"
                    continue
                else
                    re='^[0-9]+$'
                    if ! [[ $propertyValue =~ $re ]] ; then
                        printf "${orange}error: Not a number${nocolor}\n"
                        continue
                    fi
                fi
                break
            done
        ;;

        text)
            while true; do
                promptTextColor=$'\033[0;32m'
                promptNoColor=$'\033[0m'
                valueColor=$'\033[0;38;5;201m'
                read -e -p "$promptNoColor Type some text for property ${promptTextColor}${property}${promptNoColor} : ${valueColor}" propertyValue

                if [ -z "$propertyValue" ]; then
                    printf "${red}Value can't be empty${nocolor}\n"
                    continue
                fi
                break
            done
        ;;

        dash-text)
            while true; do
                promptTextColor=$'\033[0;32m'
                promptNoColor=$'\033[0m'
                valueColor=$'\033[0;95m'
                read -e -p "$promptNoColor Type some text without space for property ${promptTextColor}${property}${promptNoColor} : ${valueColor}" propertyValue

                if [ -z "$propertyValue" ]; then
                    printf "${red}Value can't be empty${nocolor}\n"
                    continue
                else
                    propertyValue="${propertyValue// /-}"
                fi
                break
            done
        ;;
        
        array)
            propertyValuesAsString=${ga_propertiesValues[$property]}
            IFS=' ' read -ra propertyValuesAsArray <<< "$propertyValuesAsString"

            printf "${graybold}availables values for ${property}\n${nocolor}"

            printf "${gray}"
            PS3='Select value in the list : '
            select opt in "${propertyValuesAsArray[@]}"; do
                case "$opt" in
                    "") continue ;;
                    *)
                        printf "${nocolor}"
                        propertyValue=$opt
                        break
                        ;;
                esac
            done
        ;;

        none)
            printf "${orange}property ${property} can't be edited\n${nocolor}"
            # break
            AskForPropertyValue_failed="true"
        ;;
    esac
    
    if [ "$AskForPropertyValue_failed" != "true" -a "$g_isVerboseActive" == "true" ] ; then
        printf "${gray}${property}=${blue}${propertyValue}${nocolor}\n"
    fi
}



##############
## COMMANDS ##
##############

ClearAllServers () {
    printf "${green}Theses servers will be removed :${nocolor}\n"
    ls -ACDtu1 instances
    read -e -p $'\033[0;38;5;178m  Are you sure ?\033[0m O/n : ' -i "O" clearValidation
    if [ "${clearValidation}" == "O" -o "${clearValidation}" == "o" ]; then
        # printf "${gray}deleting...${nocolor}\n"
        # printf "${red}"
        # rm -rf instances/*
        # printf "${yellow}"
        # ls -ltr instances
        # printf "${nocolor}"
        ClearDir "./instances"
    else
        printf "${graydim}nothing done.${nocolor}\n"
    fi
    printf "\n"
}

RemoveServer () {
    SelectServer
    if [ "$SelectServer_failed" == "true" ]; then 
        echo "instances/ dir not exists"
    else
        ClearDir "$g_serversDIR/$selectedServer"
    fi
}

ListAllServers () {
    nb="$(ls instances/ | wc -l)"
    if [ $nb -gt 0 ]; then
        printf "${green}  Minecraft servers :${gray} ${nb} ${nocolor}\n"
        printf "${gray}"
        ls -ACDtu1 instances
        printf "${nocolor}"
    else
        printf "${yellow}  No minecraft servers\n${nocolor}"
        printf "${gray}Use ${blue}srvmng --deploy ${gray}to create one\n${nocolor}"
    fi
    printf "\n"
}

CreateServer () {
    # clear
}