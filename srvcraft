#!/bin/bash

####################
## Minecraft Server Command
## Author : Alexis Cotel
## Version : 1.0.0
## License : MIT
## See https://github.com/alexiscotel/minecraftserver_command/README.md for more explainations
####################

# This script is a wrapper for minecraft server jar file
# It's a bash script with some functions to manage minecraft server

# Minecraft versions Java compatibility
# 1.12 -> 1.16.5 = Java 8
# 1.17 -> 1.17.1 = Java 16
# 1.18 = Java 17


commandPath=$0
commandName=`basename "$commandPath"`

# work only on linux
wget=/usr/bin/wget


############
## COLORS ##
############
nocolor='\033[0m'
whiite='\033[0;97m'
whiitebold='\033[0;1;97m'
purple='\033[0;38;5;201m'
blue='\033[0;38;5;45m'
blueblink='\033[0;5;38;5;45m'
darkblue='\033[0;38;5;27m'
green='\033[0;32m'
greendim='\033[0;3;32m'
yellow='\033[0;38;5;178m'
orange='\e[0;3;38;5;166m'
gray='\033[0;38;5;249m'
graybold='\033[0;1;38;5;249m'
graydim='\033[0;2;38;5;250m'
red='\033[0;91m'
## CUSTOM
c__functionName='\033[0;38;5;45m'
c__listHeader='\033[0;97m'
c__listLine='\033[0;38;5;249m'




##################
## GLOBALS VARS ##
# true is shell command and always return 0 
# false always return 1
##################
g_isJavaInstalled="false"

g_repoURL="git@github.com:alexiscotel/srvcraft.git" #minecraftserver_command
g_tmpInstallDIR="./tmp"

g_serversDIR="./instances"
g_loaderDIR="./loader"
g_downloadDIR="${g_loaderDIR}/downloads"

g_screenPrefix="mcserver"

## PRINT
g_isVerboseActive="true"
g_isDoubleVerboseActive="false"

# list of availables versions and its download URL, in order (check https://mcversions.net for update)
declare -a g_versionsList=(
    "1.19.3"
    "1.19.2"
    "1.19"
)
declare -a g_versionsURLList=(
    "https://piston-data.mojang.com/v1/objects/c9df48efed58511cdd0213c56b9013a7b5c9ac1f/server.jar"
    "https://piston-data.mojang.com/v1/objects/f69c284232d7c7580bd89a5a4931c3581eae1378/server.jar"
    "https://launcher.mojang.com/v1/objects/e00c4052dac1d59a1188b2aa9d5a87113aaf1122/server.jar"
)
# Associative array of property name and his value
declare -A ga_loaderServerProperties

declare -A ga_serverPropertiesAllowValues=(
    ['view-distance']="number"
    ['simulation-distance']="number"
    ['entity-broadcast-range-percentage']="number"
    ['use-native-transport']="boolean"
    ['server-ip']="IP"
    ['server-port']="number"
    ['motd']="text"
    ['enable-status']="boolean"
    ['enforce-secure-profile']="boolean"
    ['prevent-proxy-connections']="boolean"
    ['white-list']="boolean"
    ['enforce-whitelist']="boolean"
    ['online-mode']="boolean"
    ['hide-online-players']="boolean"
    ['max-players']="number"
    ['pvp']="boolean"
    ['player-idle-timeout']="number"
    ['rate-limit']="number"
    ['force-gamemode']="boolean"
    ['gamemode']="array"
    ['difficulty']="array"
    ['level-type']="array"
    ['hardcore']="boolean"
    ['enable-command-block']="boolean"
    ['allow-flight']="boolean"
    ['level-name']="dash-text"
    ['level-seed']="number"
    ['generator-settings']="none"
    ['max-world-size']="number"
    ['generate-structures']="boolean"
    ['spawn-npcs']="boolean"
    ['spawn-animals']="boolean"
    ['spawn-monsters']="boolean"
    ['allow-nether']="boolean"
    ['spawn-protection']="boolean"
    ['initial-enabled-packs']="dash-text"
    ['initial-disabled-packs']="dash-text"
    ['resource-pack']="dash-text"
    ['resource-pack-sha']="dash-text"
    ['require-resource-pack']="boolean"
    ['resource-pack-prompt']="text"
    ['op-permission-level']="number"
    ['broadcast-console-to-ops']="boolean"
    ['function-permission-level']="number"
    ['enable-rcon']="boolean"
    ['broadcast-rcon-to-ops']="boolean"
    ['rcon.password']="dash-text"
    ['rcon.port']="number"
    ['enable-query']="boolean"
    ['query.port']="number"
    ['enable-jmx-monitoring']="boolean"
    ['max-chained-neighbor-updates']="none"
    ['max-tick-time']="none"
    ['network-compression-threshold']="none"
    ['sync-chunk-writes']="none"
    ['text-filtering-config']="none"
)

declare -A ga_serverPropertiesAllowValuesList=(
    ['gamemode']="survival creative adventure spectator"
    ['difficulty']="peaceful easy normal hard"
    ['level-type']="minecraft\:normal minecraft\:flat minecraft\:large_biomes minecraft\:single_biome_surface"
)

# create for each allows values a list of values
# for key in "${!ga_serverPropertiesAllowValuesList[@]}"; do
#     local values="${ga_serverPropertiesAllowValuesList[$key]}"
#     local valuesList=""
#     for value in $values; do
#         valuesList="${valuesList} ${value}"
#     done
#     ga_serverPropertiesAllowValuesList[$key]="${valuesList}"
# done



####################
## DOWNLOAD FUNCTONS
####################

# @Function : List all lines from a directory with regex filter (arg 2)
# @Params
#   $1 repository
# @LastMessage: "Start clonning"
# UseCase : CloneRepo
CloneRepo () {
    repo=$1
    repoDir="tmp"

    if [ "$g_isVerboseActive" == "true" ]; then
        printf "${gray}Start cloning repository ...${nocolor}\n"
    fi

    ClearDir $repoDir
    mkdir $repoDir

    printf "${graydim}"
    git clone $g_repoURL $repoDir
    printf "${nocolor}"
}

# @Function : Download minecraft server with specific version passed in param
# @Params
#   $1 version
# @Result : download the file in the g_downloadDIR as "server.${version}.jar"
# UseCase : DownloadMinecraftServerVersion "1.19.3"
# - if [ "$DownloadMinecraftServerVersion_failed" == "true" ]; then echo "error when download" else echo "download ok | file present" fi
DownloadMinecraftServerVersion () {
    DownloadMinecraftServerVersion_failed="false"

    if [ ! -d "$g_downloadDIR" ]; then
        mkdir -p $g_downloadDIR
    fi # endof if param is empty

    local version=$1

    # test if param is empty
    if [ -z "$version" ]; then
        printf "${red}version param is empty${nocolor}\n"
        DownloadMinecraftServerVersion_failed="true"
    else

        local filename="server.${version}.jar"

        printf "  ${gray}asking for${nocolor} ${filename}\n"

        if test ! -f "${g_downloadDIR}/${filename}" ; then
            local url=""
            case $version in
                "1.19.3")
                    url="https://piston-data.mojang.com/v1/objects/c9df48efed58511cdd0213c56b9013a7b5c9ac1f/server.jar"
                    ;;
                "1.19.2")
                    url="https://piston-data.mojang.com/v1/objects/f69c284232d7c7580bd89a5a4931c3581eae1378/server.jar"
                    ;;
                "1.19.1")
                    url="https://piston-data.mojang.com/v1/objects/8399e1211e95faa421c1507b322dbeae86d604df/server.jar"
                    ;;
                "1.19")
                    url="https://launcher.mojang.com/v1/objects/e00c4052dac1d59a1188b2aa9d5a87113aaf1122/server.jar"
                    ;;
                # "1.18.2")
                #     url="https://launcher.mojang.com/v1/objects/c8f83c5655308435b3dcf03c06d9fe8740a77469/server.jar"
                #     ;;
                # "1.18.1")
                #     url="https://launcher.mojang.com/v1/objects/125e5adf40c659fd3bce3e66e67a16bb49ecc1b9/server.jar"
                #     ;;
                # "1.18")
                #     url="https://launcher.mojang.com/v1/objects/3cf24a8694aca6267883b17d934efacc5e44440d/server.jar"
                #     ;;
            esac
            if [ -z "${url}" ]; then
                printf "    ${red}version number not found in list${nocolor}\n"
                DownloadMinecraftServerVersion_failed="true"
            else

                # start getting the jar file
                printf "${gray}start download ... ${nocolor}\n"
                printf "${graydim}"
                # cd $downloadDir
                $wget -O "${g_downloadDIR}/${filename}" "$url"
                # cd "../../"
                printf "${nocolor}"
                printf "${gray}download finished${nocolor} "
                if [ -z "${g_downloadDIR}/${filename}" ]; then
                    # error
                    printf "${red}with failed, server.jar not found.${nocolor}\n"
                    exit 0
                else
                    # good
                    printf "${greendim}with success.${nocolor}\n"
                fi

            fi

            
        else
            printf "${yellow}.jar file already present on server${nocolor}\n"
        fi

    fi # endof if param is empty
}



##########################
## FILESYSTEM FUNCTIONS ##
##########################

# @Function : List all items from a directory with regex filter (arg 2)
# @Params
#   $1 directory
#   $2 filter regex
# @LastMessage: Total of items
# UseCase : ListDir "path/to/dir" ".*"
ListDir () {
    dir=$1

    if [ "$dir" == "*" ]; then
        dirbasename=$1
        listarray=$(find $dir -maxdepth 1)
    fi
    if [ "$dir" != "*" ]; then 
        dirbasename="$(basename -- $dir)"
        listarray=$(find $dir/* -maxdepth 1)
    fi

    excludeRegex=$2
    col=$3

    if [ -z "$2" ]; then
        if [ "$dir" == "*" ]; then
            listarray=$(find $dir -maxdepth 1)
        fi
        if [ "$dir" != "*" ]; then 
            listarray=$(find $dir/* -maxdepth 1)
        fi
    else
        if [ "$dir" == "*" ]; then 
            listarray=$(find $dir -maxdepth 1 ! -name \'$excludeRegex\')
        fi
        if [ "$dir" != "*" ]; then
            listarray=$(find $dir/* -maxdepth 1 ! -name \'$excludeRegex\')
        fi
    fi
    if [ -z "$3" ] ; then
        col=false
    else
        col=$3
    fi

    printf "${gray}List of${whiitebold} ${dirbasename} ${nocolor}\n"
    cpt=0
    if test $col == "false"; then
        printf "  "
    fi
    printf "${gray}"
    for line in $listarray; do
        f="$(basename -- $line)"
        if [[ -d $f ]]; then
            cpt=$((cpt+1))
            printf "${darkblue}"
            printf "${f} ${nocolor}"
            if test $col == "true"; then
                printf "\n"
            fi
        elif [[ -f $f ]]; then
            cpt=$((cpt+1))
            printf "${whiite}"
            printf "${f} ${nocolor}"
            if test $col == "true"; then
                printf "\n"
            fi
        fi
    done
    printf "\n${nocolor}"
    printf "${graydim}TOTAL :${whiitebold} $cpt ${nocolor}\n"
}
# @Function : Create dir passed in parameter
# @Params
#   $1 directory
# @LastMessage: "exist" or "completed" or "error"
# UseCase : CreateDir "test/"
CreateDir () {
    dir=$1
    
    if [ "$g_isVerboseActive" == "true" ]; then
        printf "${gray}create dir${whiite} \"${dir}\" ${nocolor}... "
    fi
    
    if [ ! -d "$dir" ]; then
        mkdir -p "${dir}"
        
        if [ -d "$dir" ]; then
            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${greendim} complete${nocolor}\n"
            fi
        else
            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${red} error${nocolor}\n"
            fi
            exit 0
        fi
    else
        if [ "$g_isVerboseActive" == "true" ]; then
            printf " ${yellow}allready exists. ${nocolor}\n"
        fi
    fi
}
# @Function : Remove dir passed in parameter
# @Params
#   $1 directory
# @LastMessage: "completed" or "error"
# UseCase : ClearDir "path/to/dir"
ClearDir () {
    dir=$1
    if [ -d "$dir" ]; then
        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${gray}Removing${whiite} ${dir} ${gray}...${nocolor} "
        fi
        printf "${red}"
        rm -rf $dir
        printf "${nocolor}"

        if [ "$g_isVerboseActive" == "true" ]; then
            if [ ! -d "$dir" ]; then
                printf "${green} with success${nocolor}\n"
            else
                printf "${red} with error. dir${whiite} ${dir} ${red}still exists${nocolor}\n"
            fi
        fi
    fi
}
# @Function : Rename dir passed in parameter
# @Params
#   $1 directory
# @LastMessage: "completed" or "error"
# UseCase : RenameServer "servername"
RenameServer () {
    serverExists="false"
    servername=$1

    if [ -z "$servername" ]; then
        printf "${red}param empty${nocolor}\n"
    else
        if [ -d "$g_serversDIR/$servername" ]; then
            printf "${yellow}a server with this name allready exists ${graydim}($g_serversDIR/$servername)${nocolor}\n"
            local cpt=0
            local newName="${cpt}-${servername}"
            while [ -d "$g_serversDIR/$newName" ]; do
                cpt=$((cpt+1))
                newName="${cpt}-${servername}"
            done
            printf "${gray}  Rename ${whiite}\"$servername\" ${gray}as ${whiite}\"$newName\" ${nocolor}\n"
            mv "$g_serversDIR/$servername" "$g_serversDIR/$newName"
        else
            printf "${red}can't rename server \"$servername\", \"$g_serversDIR/$servername\" not found${nocolor}\n"
        fi
    fi
}
# @Function : Copy file passed from parameter
# @Params
#   $1 path file source
#   $1 path file destination
# @LastMessage: "completed" or "error"
# @UseCase : CopyFile "path/to/source" "path/to/destination"
CopyFile () {
    file=$1
    fileDir=$2

    if [ "$g_isVerboseActive" == "true" ]; then
        printf "${gray}create file${whiite} \"${fileDir}/${file}\" ${nocolor}... "
    fi

    if [ ! -d "${fileDir}" ]; then

        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${yellow}dir not found.${nocolor}\n"
        fi
        exit 0
    fi
    
    if [ ! -f "${fileDir}/${file}" ]; then
        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${yellow}file not found. ${gray}Start copy ... ${nocolor} "
        fi
        printf "${red}"
        cp -r "tmp/${fileDir}/${file}" "${fileDir}/${file}"
        printf "${nocolor}"
        
        if [ ! -f "${fileDir}/${file}" ]; then
            # error
            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${red}with failed, \"${fileDir}/${file}\" not found.${nocolor}\n"
            fi
            exit 0
        else
            # good
            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${greendim}with success.${nocolor}\n"
            fi
        fi
    else
        if [ "$g_isVerboseActive" == "true" ]; then
            printf " ${yellow}allready exists. ${nocolor}\n"
        fi
    fi
}
# @Function : Check if a server folder exists
# @Params
#   $1 servername
# UseCase : CheckExistingServer "my-server.1.19.3"
# - if [ "$serverExists" == "true" ]; then echo "server dir found" else echo "server dir not found" fi
CheckExistingServer () {
    serverExists="false"
    servername=$1

    if [ -z "$servername" ]; then
        printf "${red}param empty${nocolor}\n"
    else
        if [ -d "$g_serversDIR/$servername" ]; then
            serverExists="true"
        else
            serverExists="false"
        fi
    fi
}




#################################
## SERVER PROPERTIES FUNCTIONS ##
#################################

# @Function : Read loader server.properties file and put in an associative array
# @Params
#  - $1 directory (optional)
# @Result : upadte $ga_serverPropertiesArray array
# @UseCase : 
#  - LoadServerPropertiesFile "path/to/server.properties"
#  - if [ "$LoadServerPropertiesFile_status" == "true" ]; then echo "Job failed" else echo "Job done" fi
declare -A ga_serverPropertiesArray
LoadServerPropertiesFile () {

    LoadServerPropertiesFile_failed="false"
    sourceFile=$1

    if [ "$g_isDoubleVerboseActive" == "true" ]; then
        printf "${c__functionName} > LoadServerPropertiesFile ${nocolor}\n"
    fi

    # test if param is empty
    if [ -z "$sourceFile" ]; then
        if [ "$g_isDoubleVerboseActive" == "true" ]; then
            printf "${yellow}param empty${nocolor}\n"
        fi
        sourceFile="${g_loaderDIR}/server.properties"
    fi # endof if param is empty

    # test if file exists
    if [ ! -f "$sourceFile" ]; then
        # file not exists - update status value
        LoadServerPropertiesFile_failed="true"
    else
        IFS='='
        while IFS= read -r line
        do
            if [ -n "${line}" ]; then
                hastag=${line:0:1}

                if [ "${hastag}" != "#" ]; then
                    read -a strarr <<< "$line"
                    key="${strarr[0]}"
                    value="${strarr[1]}"
                    

                    ## BUG : to by-pass query.port array assignement
                    if [[ ! $key == *.* ]] ; then
                        
                        ga_serverPropertiesArray["$key"]="${value}"

                        if [ "$g_isDoubleVerboseActive" == "true" ] ; then
                            printf "${graydim}  > ${key} =${gray} ${value} ${nocolor}\n"
                        fi
                    else
                        if [ "$g_isDoubleVerboseActive" == "true" ] ; then
                            printf "${red}  > ${key} skip ${nocolor}\n"
                        fi
                    fi
                fi
            fi
        done <"$sourceFile"

        IFS=$'\n' tmp_array_sorted=($(sort <<<"${tmp_array[*]}")); unset IFS
    fi # endof if file exists
}
# @Function : list items of g_versionsList
# @UseCase : 
#  - ListServerProperties
ListServerProperties () {
    local cpt=0
    printf "${gray}List of${whiitebold} Versions ${nocolor}\n${gray}"
    for version in ${g_versionsList[@]}; do
        cpt=$((cpt+1))
        printf "${version}" 
        if ! exists $version in $g_versionsList; then printf " ${yellow}No URL"; fi
        printf "${nocolor}\n"
    done
}

# @Function : Update server.properties file passed in param with global array $ga_serverPropertiesArray values
# @Param : 
# - $1 serverFile
# @UseCase : 
# - UpdateServerPropertiesFile
# - if [ "$updateServerPropertiesFile_failed" == "true" ]; then echo "server.properties file not found" else echo "file updated" fi
UpdateServerPropertiesFile () {
    updateServerPropertiesFile_failed="false"
    serverFile=$1

    # test if param is empty
    if [ -z "$serverFile" ]; then
        updateServerPropertiesFile_failed="true"

        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${red}server file ${gray}\"${serverFile}\" ${red}not found${nocolor}\n"
        fi
    else
        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${gray}applying in file ...${nocolor}\n"
        fi

        local prefix="${g_serversDIR}/"
        local suffix="/server.properties"
        local serverFileName=${serverFile#"$prefix"}
        serverFileName=${serverFileName%"$suffix"}
        local date=$(date +"%Y-%m-%d %H:%M:%S")
        echo "# [srvcraft] ${serverFileName} | last update : ${date}" > $serverFile

        for key in ${!ga_serverPropertiesArray[@]}; do
            echo "${key}=${ga_serverPropertiesArray[${key}]}" >> $serverFile

            if [ "$g_isDoubleVerboseActive" == "true" ]; then
                printf "${gray} ${key} =${blue} ${ga_serverPropertiesArray[${key}]} ${nocolor}\n"
            fi
        done

        if [ "$g_isDoubleVerboseActive" == "true" ]; then
            printf "${gray}file ${whiite}\"${serverFile}\" ${green}updated !${nocolor}\n"
        fi
    fi
}



####################
## JAVA FUNCTIONS ##
####################
# /!\ Useless for minecraft server version later than 1.18
# Server/Requirements 1.19.3 :
# As of version 1.17, JRE version 16 is required. For version 1.18, JRE version 17 is required

CheckForJavaInstall () {
    if [ -z "$JAVA_HOME" ]; then
        g_isJavaInstalled="false"
        printf "${red}JAVA_HOME is not set${nocolor}\n"
        printf "${yellow}Please install java and set JAVA_HOME variable ${gray}(./docs/linux-install.md)${nocolor}\n"
    else
        g_isJavaInstalled="true"
    fi
}



################################
## MINECRAFT SERVER FUNCTIONS ##
################################

# @Function : Start server a first time to initialize files and folders
# @Params
#  - $1 servername
#  - $2 serverVersion
#  - $3 memory
# @UseCase : 
#  - InitialiseServer "my-server.1.19.3" "1024M"
#  - if [ "$InitialiseServer_failed" == "true" ]; then echo "Job failed" else echo "Job done" fi
InitialiseServer () {
    InitialiseServer_failed="false"
    # local servername=$1
    local serverNameDir=$1
    # local serverVersion=$2
    local memory=$2

    # test if param servername is empty
    if [ -z "$serverNameDir" ]; then
        printf "${red}serverNameDir param is empty${nocolor}\n"
        InitialiseServer_failed="true"
    else

        local serverDir="${g_serversDIR}/${serverNameDir}"
        # test if dir exists
        if [ ! -d "${serverDir}" ]; then
            printf "${red}server \"${serverDir}\" dir not found${nocolor}\n"
            InitialiseServer_failed="true"
        else

            # test if param memory is empty
            if [ -z "$memory" ]; then
                printf "${red}memory param is empty. adjust to ${blue}1024M${nocolor}\n"
                memory="1024M"
            fi # endof if memory param

            if ! [[ "$memory" =~ ^([0-9]+)[MG]$ ]]; then
                printf "${red}Memory must be a valid number and quantifier ([0-9][MG]${nocolor}\n"
                InitialiseServer_failed="true"
            else
                
                printf "\n${yellow}launch server a first time to initialize ${graydim}(memory : ${blue}${memory})${nocolor}\n"
                printf "${graydim}"

                local jar=$(ls -1 "${serverDir}" | grep ".*\.jar")

                local actualDir=$(pwd)
                cd ${serverDir}
                # java -Xmx$memory -Xms$memory -jar "server.${serverVersion}.jar" nogui
                java -Xmx$memory -Xms$memory -jar "${jar}" nogui
                cd ${actualDir}

                printf "${nocolor}";
                printf "${yellow}Server stop due to incorrects eula terms${nocolor}\n"
                
                printf "${red}"
                echo "eula=true" > "${serverDir}/eula.txt"
                printf "${nocolor}";

                printf "${blueblink} EULA terms accepted${nocolor}\n"

            fi

        fi # endof if dir exists 
        
    fi # endof if serverDirName param
}

# @Function : Start the server
# @Params
#  - $1 servername
#  - $3 memory
# @UseCase : 
#  - StartServer "my-server.1.19.3" "1024M"
#  - if [ "$StartServer_failed" == "true" ]; then echo "Job failed" else echo "Job done" fi
StartServer () {
    StartServer_failed="false"
    local serverNameDir=$1
    local memory=$2

    # test if param servername is empty
    if [ -z "$serverNameDir" ]; then
        printf "${red}serverNameDir param is empty${nocolor}\n"
        StartServer_failed="true"
    else

        local serverDir="${g_serversDIR}/${serverNameDir}"
        # test if dir exists
        if [ ! -d "${serverDir}" ]; then
            printf "${red}server \"${serverDir}\" not found${nocolor}\n"
            StartServer_failed="true"
        else

            ## test si fichiers pr√©sents
            if [ ! -d "${serverDir}/libraries" ]; then
                printf "${red}server is not initialized ${graydim}(libraries/ dir not found)${nocolor}\n"
                StartServer_failed="true"
            else

                # test if param memory is empty
                if [ -z "$memory" ]; then
                    printf "${red}memory param is empty. adjust to ${blue}1024M${nocolor}\n"
                    memory="1024M"
                fi # endof if memory param

                if ! [[ "$memory" =~ ^([0-9]+)[MG]$ ]]; then
                    printf "${red}Memory must be a valid number and quantifier ([0-9][MG]${nocolor}\n"
                    StartServer_failed="true"
                else
                    
                    printf "${gray}Start ${green}\"${serverNameDir}\"${nocolor} (${gray}Memory: ${blue}${memory}${gray})${nocolor}\n"
                    printf "${orange}${nocolor}\n"

                    local jar=$(ls -1 "${serverDir}" | grep ".*\.jar")

                    printf "${gray}"

                    StartScreenSession "$1" "$2"
                fi

            fi # endof if dir exists

        fi # endof if dir exists

    fi # endof if serverDirName param
}



######################
## SCREEN FUNCTIONS ##
######################

# @Function : Check if screen session passed in param exists
# @Params
#  - $1 sessionName
# @UseCase : 
#  - CheckIfScreenSessionExists "toto.1.19.2"
#  - if [ "$CheckIfScreenSessionExists_failed" == "true" ]; then echo "Job failed" else echo "Job done" fi
CheckIfScreenSessionExists () {
    CheckIfScreenSessionExists_failed="false"
    local sessionName=$1

    screenSessionExists="false"

    # test if param is empty
    if [ -z "$sessionName" ]; then
        CheckIfScreenSessionExists_failed="true"

        if [ "$g_isDoubleVerboseActive" == "true" ]; then
            printf "${red}Checking screen session : sessionName param is empty${nocolor}\n"
        fi
    else
        if [ "$g_isDoubleVerboseActive" == "true" ]; then
            printf "${gray}Start checking session \"${sessionName}\" ...${nocolor}\n"
        fi

        local test=$(screen -list | grep "${sessionName}")
        if [ -z "$test" ]; then
            screenSessionExists="false"

            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${yellow}Screen session ${whiite}\"${sessionName}\"${yellow} does not exists${nocolor}\n"
            fi
        else
            if [[ "$test" =~ ^(No Sockets found) ]]; then
                screenSessionExists="false"
                if [ "$g_isDoubleVerboseActive" == "true" ]; then
                    printf "${orange}Screen session ${whiite}\"${sessionName}\"${yellow} does not exists${nocolor}\n"
                fi
            else
                screenSessionExists="true"
                if [ "$g_isDoubleVerboseActive" == "true" ]; then
                    printf "${gray}Screen session exists${nocolor}\n"
                fi
            fi
        fi
    fi
}

# @Function : Start a server in a screen session
# @Params
#  - $1 sessionName
# @UseCase : 
#  - StartScreenSession "toto.1.19.2"
#  - if [ "$StartScreenSession_failed" == "true" ]; then echo "Job failed" else echo "Job done" fi
StartScreenSession () {
    StartScreenSession_failed="false"
    local serverName=$1

    if [ "$g_isVerboseActive" == "true" ]; then 
        printf "${whiite}Starting screen command ...${nocolor}\n"
    fi

    # test if param is empty
    if [ -z "$serverName" ]; then
        printf "${red}sessionName param is empty${nocolor}\n"
        StartScreenSession_failed="true"
    else
        sessionName="${g_screenPrefix}.${serverName}"

        CheckIfScreenSessionExists "${sessionName}"
        if [ "$CheckIfScreenSessionExists_failed" == "true" ]; then
            printf "${red}CheckIfScreenSessionExists failed${nocolor}\n"
        else

            if [ "$screenSessionExists" == "true" ]; then
                StartScreenSession_failed="true"
                printf "${yellow}Session ${whiite}\"${sessionName}\"${yellow} allready exists${nocolor}\n"
                printf "${gray}Use ${whiite}\"screen -r ${sessionName}\"${nocolor} to attach to it\n"
            else 
                if [ ! -d "${g_serversDIR}/${serverName}" ]; then
                    StartScreenSession_failed="true"
                    printf "${red}Server ${whiite}\"${serverName}\"${red} not found${nocolor}\n"
                else
                    local jar=$(ls -1 "${g_serversDIR}/${serverName}" | grep ".*\.jar")
                    memory="2048M"

                    local actualDir=$(pwd)
                    cd "${g_serversDIR}/${serverName}"
                    screen -S "${sessionName}" -dm bash -c "java -Xmx$memory -Xms$memory -jar "${jar}" nogui && exec sh"

                    AttachToScreen "${sessionName}"
                    if [ "$AttachToScreen_failed" == "true" ]; then 
                        printf "${red}Screen failed to attach${nocolor}\n"
                    else
                        printf "${gray}Screen was attached ${green}with success${nocolor}\n"
                    fi

                    # screen -S "${sessionName}" -dm bash -c "exec sh"
                fi
            fi
        fi
    fi
}

# @Function : Attach the current terminal to passed in param screen session
# @Params
#  - $1 sessionName
# @UseCase : 
#  - AttachToScreen "mcserver.toto.1.19.2"
#  - if [ "$AttachToScreen_failed" == "true" ]; then echo "Job failed" else echo "Job done" fi
AttachToScreen () {
    echo "attach to screen"

    AttachToScreen_failed="false"
    local sessionName=$1

    # test if param is empty
    if [ -z "$sessionName" ]; then
        printf "${red}sessionName param is empty${nocolor}\n"
        AttachToScreen_failed="true"
    else
        CheckIfScreenSessionExists "${sessionName}"
        if [ "$CheckIfScreenSessionExists_failed" == "true" ]; then
            printf "${red}AttachToScreen failed${nocolor}\n"
        else 
            # printf "AttachToScreen ${green}done${noclor}\n"

            if [ "$screenSessionExists" == "false" ]; then
                printf "${yellow}Session ${whiite}\"${sessionName}\"${yellow} not found${nocolor}\n"
            else 
                printf "${gray}Session ${whiite}\"${sessionName}\"${green} found${nocolor}\n"

                screen -r "${sessionName}"
            fi
        fi
    fi
}

# @Function : Detach the passed in param screen from TTY
# @Params
#  - $1 sessionName
# @UseCase : 
#  - DetachFromScreen "toto.1.19.2"
#  - if [ "$DetachFromScreen_failed" == "true" ]; then echo "Job failed" else echo "Job done" fi
DetachFromScreen () {
    echo "detach from screen"

    DetachFromScreen_failed="false"
    local sessionName=$1

    # test if param is empty
    if [ -z "$sessionName" ]; then
        printf "${red}sessionName param is empty${nocolor}\n"
        DetachFromScreen_failed="true"
    else
        CheckIfScreenSessionExists "${sessionName}"
        if [ "$CheckIfScreenSessionExists_failed" == "true" ]; then
            printf "${red}DetachFromScreen failed${nocolor}\n"
        else 
            # printf "DetachFromScreen ${green}done${noclor}\n"

            if [ "$screenSessionExists" == "false" ]; then
                printf "${yellow}Session ${whiite}\"${sessionName}\"${yellow} not found${nocolor}\n"
            else 
                printf "${gray}Session ${whiite}\"${sessionName}\"${green} found${nocolor}\n"

                screen -d "${sessionName}"
                # screen -S "${sessionName}" -p 0 -X kill
            fi
        fi
    fi
}

# @Function : List all mcserver screen sessions
# @UseCase : 
#  - ListScreenSessions
ListScreenSessions () {
    serverSessionRunning="false"
    
    local screenCmd=$(screen -list | grep "$g_screenPrefix")
    if [ -z "$screenCmd" ]; then
        serverSessionRunning="false"

        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${orange}No screen sessions found with ${yellow}\"mcserver\"${orange} prefix${nocolor}\n"
        fi
    else
        if [[ "$screenCmd" =~ ^(No Sockets found) ]]; then
            serverSessionRunning="false"
            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${green}No screen session running${nocolor}\n"
            fi
        else
            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${whiite}List of screen sessions :${nocolor}\n"
            fi

            local startLine="There"

            cmdScreenNameArray=()
            while IFS= read -r line; do
                cmdScreenNameArray+=( "$line" )
            done < <( screen -list | grep "$g_screenPrefix" | awk '{print $1}' )
            cmdScreenStatusArray=()
            while IFS= read -r line; do
                cmdScreenStatusArray+=( "$line" )
            done < <( screen -list | grep "$g_screenPrefix" | awk '{print $4}' )

            for i in "${!cmdScreenNameArray[@]}"; do 
                if [[ ${cmdScreenNameArray[$i]} != "There"* ]] && [[ ${cmdScreenStatusArray[$i]} != "/run"* ]]; then
                    local cmdScreenName=${cmdScreenNameArray[$i]}
                    cmdScreenName=${cmdScreenName:6}

                    local cmdScreenStatus=${cmdScreenStatusArray[$i]}
                    cmdScreenStatus=$(echo "${cmdScreenStatus}" | sed 's/[)(]//g')

                    local color="${gray}"
                    if [ "$cmdScreenStatus" == "Attached" ]; then
                        color="${green}"
                    elif [ "$cmdScreenStatus" == "Detached" ]; then
                        color="${yellow}"
                    else
                        color="${graydim}"
                    fi

                    printf "${color}${cmdScreenStatus}${nocolor} ${cmdScreenName}\n"
                fi
            done


            # serverSessionRunning="true"
            # if [ "$g_isVerboseActive" == "true" ]; then
            #     printf "${yellow}At least one screen is running${nocolor}\n"
            # fi
        fi
    fi
}

# @Function : Clear all mcserver screen sessions that detached
# @UseCase : 
#  - ClearDetachedScreens
ClearDetachedScreens () {
    screen -list | grep "$g_screenPrefix" | grep Detached | awk '{print $1}' | while read in; 
    do 
        screen -X -S $in quit

        cmdScreenName=${in:6}
        printf "${graydim}Delete screen ${gray}\"$cmdScreenName\" ${graydim}...${nocolor}\n"
    done
}

# @Function : Attach the current terminal to passed in param screen session
# @Params
#  - $1 screenName
# @Result :
#  - AttachScreenSession_failed : true if failed, false if success
#  - cmdScreenName : 'pid.server-name.version'
#  - cmdScreenDate : (JJ/MM/AAAA HH:MM:SS)
#  - cmdScreenStatus : (Attached | Detached)
# @UseCase : 
#  - GetScreenInfos "mcserver.toto.1.19.2"
#  - if [ "$GetScreenInfos_failed" == "true" ]; then echo "GetScreenInfos failed" else echo "GetScreenInfos done" fi
GetScreenInfos () {
    GetScreenInfos_failed="false"
    screenName=$1
    
    if [ -z "$screenName" ]; then
        GetScreenInfos_failed="true"

        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${orange}ScreenName param empty${nocolor}\n"
        fi
    else
        cmdScreenName=""
        cmdScreenDate=""
        cmdScreenStatus=""
        
        cmd=$(screen -list | awk -v pat="$screenName" '$0 ~ pat')

        if [ -z "$cmd" ]; then
            if [ "$g_isVerboseActive" == "true" ]; then
                printf "${red}Screen session not found${nocolor}\n"
            fi
        else
            if [ "$g_isDoubleVerboseActive" == "true" ]; then
                printf "${green}Screen session found${nocolor}\n"
            fi
            
            IFS=$'\t' read -r -a cmdAarray <<< "$cmd"

            cmdScreenName="${cmdAarray[0]}"
            cmdScreenName=${cmdScreenName:6}

            cmdScreenDate="${cmdAarray[1]}"
            cmdScreenDate=$(echo "${cmdScreenDate}" | sed 's/[)(]//g')

            cmdScreenStatus="${cmdAarray[2]}"
            cmdScreenStatus=$(echo "${cmdScreenStatus}" | sed 's/[)(]//g')
        fi
    fi
}

GetScreenInfoInline () {
    GetScreenInfos_failed="false"
    inScreen="false"
    screenName=$1

    if [ -z "$screenName" ]; then
        GetScreenInfos_failed="true"
        inScreen="false"
        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${red}ScreenName param empty${nocolor}\n"
        fi
    else
        cmdScreenName=""
        cmdScreenDate=""
        cmdScreenStatus=""
        
        cmd=$(screen -list | awk -v pat="$screenName" '$0 ~ pat')

        if [ ! -z "$cmd" ]; then
            inScreen="true"
            IFS=$'\t' read -r -a cmdAarray <<< "$cmd"

            cmdScreenName="${cmdAarray[0]}"
            cmdScreenName=${cmdScreenName:6}

            cmdScreenDate="${cmdAarray[1]}"
            cmdScreenDate=$(echo "${cmdScreenDate}" | sed 's/[)(]//g')

            cmdScreenStatus="${cmdAarray[2]}"
            cmdScreenStatus=$(echo "${cmdScreenStatus}" | sed 's/[)(]//g')
        fi
    fi
}

# @Function : Attach the current terminal to passed in param screen session
# @Result : fill g_screenList array with current screen list from mcserver
declare -a g_screenList=()
GetScreenListForSelection () {
    g_screenList=()
    local screenCmd=$(screen -list | grep "$g_screenPrefix")

    if [[ -z "$screenCmd" ]] || [[ "$screenCmd" =~ ^(No Sockets found) ]]; then
        listEmpty="true"
        if [ "$g_isDoubleVerboseActive" == "true" ]; then
            printf "${yellow}No screen session running${nocolor}\n"
        fi
    else
        listEmpty="false"

        local startLine="There"

        cmdScreenNameArray=()
        while IFS= read -r line; do
            cmdScreenNameArray+=( "$line" )
        done < <( screen -list | grep "$g_screenPrefix" | awk '{print $1}' )

        for i in "${!cmdScreenNameArray[@]}"; do 
            if [[ ${cmdScreenNameArray[$i]} != "There"* ]] && [[ ${cmdScreenStatusArray[$i]} != "/run"* ]]; then
                local cmdScreenName=${cmdScreenNameArray[$i]}
                cmdScreenName=${cmdScreenName:6}
                # cmdScreenName=${cmdScreenName#"$g_screenPrefix."}
                g_screenList+=( "$cmdScreenName" )
            fi
        done
    fi
}

# @Function : Ask for screen to use
# @Result : var versionUsed available
# @UseCase : SelectForVersion
#  - if [ "$SelectForVersion_failed" == "true" ]; then echo "SelectScreenSession failed" else echo "screen used : $screenUsed" fi
SelectScreenSession () {
    param=$1
    SelectForVersion_failed="false"
    screenUsed=""
    
    GetScreenListForSelection
    
    if [ "${#g_screenList[@]}" -gt 0  ]; then
        printf "${whiitebold}Select screen${nocolor}\n"
        PS3='Select screen : '
        select screen in "${g_screenList[@]}"; do
            case "$screen" in
                "") continue ;;
                *)
                    screenUsed=$screen
                    break
                    ;;
            esac
        done

        if [ -z "$screenUsed" ]; then
            SelectForVersion_failed="true"
        else
            if [ "$g_isDoubleVerboseActive" == "true" ] ; then
                printf "${gray}Screen used :${green} ${screenUsed} ${nocolor}\n"
            fi
        fi
    else
        printf "${red}No screens in list${nocolor}\n"
        SelectForVersion_failed="true"
    fi
}

# @Function : Remove a screen passed in param
# @Params
#  - $1 screenName
# @UseCase : RemoveScreenSession "mcserver.1.16.5"
#  - if [ "$RemoveScreenSession_failed" == "true" ]; then echo "RemoveScreenSession failed" else echo "RemoveScreenSession DONE." fi
RemoveScreenSession () {
    RemoveScreenSession_failed="false"
    screenName=$1

    if [ -z "$screenName" ]; then
        RemoveScreenSession_failed="true"

        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${orange}ScreenName param empty${nocolor}\n"
        fi
    else
        printf "${gray}Removing screen ${whiite}\"${screenName}\" ${nocolor}\n"
        printf "${red}"
        screen -X -S $screenName quit
        printf "${nocolor}"
    fi
}



#######################
## INSTALL FUNCTIONS ##
#######################

CheckCmdInstalled () {
    CheckIfCmdInstall="false"
    
    if [ -d "$g_loaderDIR" ]; then
        CheckIfCmdInstall="true"
    else
        CheckIfCmdInstall="false"
    fi
}
CheckCmdInstalled_explicit () {
    if [ -d "$g_loaderDIR" ]; then
        printf "${green}Server Manager is already installed${nocolor}\n"
    else
        printf "${yellow}No install found, try ${gray}${commandName} --install${nocolor}\n"
    fi
}

InstallCmd () {
    CloneRepo
    ClearDir "./docs"
    ClearDir "./loader"

    ROOTFILES="${g_tmpInstallDIR}/*"
    for rf in $ROOTFILES; do
        # printf "  ${gray}Processing${whiite} $rf${nocolor} "
        if [[ -d $rf ]]; then
            # printf "${blue}as directory${nocolor}\n"

            rootDir="$(basename -- $rf)"

            CreateDir $rootDir

            FILES="${rf}/*"
            for f in $FILES; do
                # printf "${gray}Processing${whiite} $f ${nocolor} "
                if [[ -d $f ]]; then

                    if [ "$g_isVerboseActive" == "true" ]; then
                        # printf "${blue}as directory${nocolor}\n"
                        printf "${yellow}nothing to do${nocolor}\n"
                    fi

                elif [[ -f $f ]]; then
                    # printf "${whiite}as file${nocolor}\n"
                    basename="$(basename -- $f)"

                    CopyFile "${basename}" "${rootDir}"
                fi
            done
        elif [[ -f $rf ]]; then
            # printf "${whiite}as file${nocolor}\n"
            basename="$(basename -- $rf)"

            CopyFile "${basename}" "."
        fi
        
        if [ "$g_isVerboseActive" == "true" ]; then
            printf "\n"
        fi
    done
    ClearDir "$g_tmpInstallDIR"

    AskForInstallGlobally
    if [ "$installGlobal" == "true" ]; then
        InstallCmdGlobally
    fi
}

InstallCmdGlobally () {
    chmod +x $commandName
    currentDir=$(pwd)
    pathDir="$HOME/bin"
    bashrc="$HOME/.bashrc"

    if [ ! -d "$pathDir" ]; then
        mkdir -p "$pathDir"
    fi

    symLink="$pathDir/$commandName"
    if [ -L ${symLink} ] ; then
        printf "${yellow}The command is already installed globally${nocolor}\n"
    elif [ -e ${symLink} ] ; then
        InstallGlobal
    else
        InstallGlobal
    fi
}

InstallGlobal () {
    printf "${gray}Creating symlink ${graydim}($currentDir/$commandName => $symLink)${nocolor}\n"
    sudo ln -s $currentDir/$commandName $symLink

    printf "${gray}Update bashrc file ...${nocolor}\n"
    echo '# add home/bin to PATH var
    export PATH="$HOME/bin:$PATH' >> $bashrc
    printf "${graydim}Try to restart ~/.bashrc${nocolor}\n"
    source $bashrc
    printf "${gray}To be sure command is available, restart the user session ${graydim}(exit from ssh for example)${nocolor}\n"
}




#####################
## ASKED QUESTIONS ##
#####################

AskForInstall () {
    CheckCmdInstalled
    if [ "$CheckIfCmdInstall" == "false" ]; then
        while true; do
            read -e -p "Do you wish to install this command (y/n) ? " -i "y" yn
            case $yn in
                [Yy]* ) 
                    InstallCmd
                    break
                ;;
                [Nn]* ) exit;;
                * ) echo "Please answer yes or no.";;
            esac
        done
    fi
}

AskForInstallGlobally () {
    installGlobal="false"
    while true; do
        read -e -p "Do you wish to install this command globally (y/n) ? " -i "y" yn
        case $yn in
            [Yy]* ) 
                installGlobal="true"
                break
            ;;
            [Nn]* ) 
                installGlobal="false"
                break
            ;;
            * ) echo "Please answer yes (y) or no (n).";;
        esac
    done
}

# @Function : Ask for server to use
# @Result : vars $selectedServer available
# @UseCase : 
# - SelectServer
# - if [ "$SelectServer_failed" == "true" ]; then echo "$g_serversDIR/ dir not exists" else echo "server selected : $selectedServer" fi
SelectServer () {
    SelectServer_failed="false"
    selectedServer=""

    # test if servers dir exists
    if [ ! -d "$g_serversDIR" ]; then
        SelectServer_failed="true"

        if [ "$g_isVerboseActive" == "true" ]; then
            printf "${red}servers directory \"${g_serversDIR}\" does not exits${nocolor}\n"
        fi
    else
        i=0
        while read line; do
            serversList[ $i ]="$line"        
            (( i++ ))
        done < <(ls -ACDtu1 "${g_serversDIR}")

        printf "${gray}"
        PS3='Select server : '
        select opt in "${serversList[@]}"; do
            case "$opt" in
                "") continue ;;
                *)
                    printf "${nocolor}"
                    selectedServer=$opt
                    break
                    ;;
            esac
        done

        if [ "$g_isDoubleVerboseActive" == "true" ]; then
            printf "${gray}Server selected :${green} ${selectedServer} ${nocolor}\n"
        fi
    fi
}

# @Function : Ask for version to use
# @Result : var versionUsed available
# @UseCase : SelectForVersion
SelectForVersion () {
    param=$1
    echo $param
    SelectForVersion_failed="false"
    versionUsed=""

    if [ -z "$param" ]; then
        # printf "\n${whiitebold}Select Version${nocolor}\n"
        PS3='Select version : '
        select v in "${g_versionsList[@]}"; do
            case "$v" in
                "") continue ;;
                *)
                    versionUsed=$v
                    break
                    ;;
            esac
        done
    else
        if [[ " ${g_versionsList[*]} " =~ " ${param} " ]]; then
            versionUsed=$param
        else
            SelectForVersion_failed="true"
            if [ "$g_isVerboseActive" == "true" ] ; then
                printf "${red}Version ${gray}${param}${red} not available ${nocolor}\n"
            fi
        fi
    fi

    if [ -z "$versionUsed" ]; then
        SelectForVersion_failed="true"
    else
        if [ "$g_isVerboseActive" == "true" ] ; then
            printf "${gray}Selected version :${green} ${versionUsed} ${nocolor}\n"
        fi
    fi
}

# @Function : Ask for server name
# @Result : vars $serverFullName & $serverName availables
# @UseCase : AskForServerName
AskForServerName () {
    param=$1
    if [ -z "$param" ]; then
        while true; do
            read -p $'\033[0;32m  Choose a name for your server :\033[0m ' serverFullName

            if [ -z "$serverFullName" ]; then
                printf "${red}Server name can't be empty${nocolor}\n"
                continue
            fi
            break
        done
    else
        serverFullName=$param
    fi

    serverName="${serverFullName// /-}"
    serverName=$(echo "$serverName" | tr '[:upper:]' '[:lower:]')
    
    if [ "$g_isVerboseActive" == "true" ] ; then
        printf "${gray}server name :${green} ${serverFullName} ${graydim}(${serverName})${nocolor}\n"
    fi
}

# @Function : Ask for how memory the server will use
# @Result : vars $memorySelected availables
# @UseCase : AskForMemory
AskForMemory () {
    AskForMemory_failed="false"
    memorySelected=""

    printf "\n${whiitebold}Memory${nocolor}\n"
    
    while true; do
        read -p $'\033[0;32m  Choose a memory for your server (in MB) :\033[0m ' memory

        if [ -z "$memory" ]; then
            printf "${red}Memory can't be empty${nocolor}\n"
            continue
        fi

        if ! [[ "$memory" =~ ^[0-9]+$ ]]; then # ^([0-9]+)[MG]$
            printf "${red}Memory must be a number${nocolor}\n"
            continue
        fi

        memorySelected="${memory}M"
        break
    done

    if [ "$g_isVerboseActive" == "true" ] ; then
        printf "${gray}memory :${green} ${memorySelected} ${nocolor}\n"
    fi
}

# @Function : Ask for config edition mode
# @Result : vars $editWithPrompt available
# @UseCase : 
# - AskForConfigEdition
# - if [ "$editWithPrompt" == "true" ]; then "use prompt to edit" echo "" else echo "use nano to edit" fi
AskForConfigEdition () {
    #colors
    promptTextColor=$'\033[0;1;97m'
    promptTextColor2=$'\033[0;1;97m'
    promptNoColor=$'\033[0m'
    valueColor=$'\033[0;38;5;45m'
    
    editWithPrompt="true"
    # if [ "$editWithPrompt" == "false" ]; then
    while true; do
        # read -e -p "$promptNoColor Use ${promptTextColor}nano${promptNoColor} edit ${promptTextColor2}server.properties$promptNoColor (y/N) ? ${promptNoColor}" -i "N" editWithPrompt
        read -e -p "${promptNoColor} Use ${promptTextColor2}Prompt${promptNoColor} or ${promptTextColor2}Nano${promptNoColor} to edit configuration (P/n) ? ${promptNoColor}" -i "p" editWithPrompt
        case $editWithPrompt in
            [Pp]* ) 
                editWithPrompt="true"
                break
                ;;
            [Nn]* ) 
                editWithPrompt="false"
                break
                ;;
            * ) printf "${red}Please answer yes or no.${nocolor}\n";;
        esac
    done
    # fi
}

# @Function : select server property (used for editing)
# @Result : vars $selectedProperty available
# @UseCase : 
# - SelectProperty $serverPropertiesArray
# - if [ "$SelectProperty_failed" == "true" ]; then echo "Property empty" else echo "property found $selectedProperty" fi
SelectProperty () {
    SelectProperty_failed="false"
    selectedProperty=""

    local serverPropertiesArray=$1

    # test if param servername is empty
    # if [ -z "$serverPropertiesArray" ]; then
    if [ ${#ga_serverPropertiesArray[@]} -eq 0 ]; then
        printf "${red}serverPropertiesArray param is empty${nocolor}\n"
        SelectProperty_failed="true"
    else

        # printf "\n${whiitebold}Select Property${nocolor}\n"
        PS3='Select property : '
        select p in ${!ga_serverPropertiesArray[@]}; do
            case "$p" in
                "") continue ;;
                *)
                    selectedProperty=$p
                    break
                    ;;
            esac
        done

        if [ -z "$selectedProperty" ]; then
            SelectProperty_failed="true"
        else
            if [ "$g_isDoubleVerboseActive" == "true" ] ; then
                printf "${gray}Selected property :${green} ${selectedProperty} ${nocolor}\n"
            fi
        fi

    fi
}

# @Function : ask for server property (used for editing)
# @Result : vars $selectedProperty available
AskForProperty () {
    #colors
    local promptTextColor=$'\033[0;32m'
    local promptTextColor2=$'\033[0;1;97m'
    local promptTextColor3=$'\033[0;3;32m'
    local promptNoColor=$'\033[0m'
    local valueColor=$'\033[0;38;5;45m'
    
    SelectProperty_failed="false"
    selectedProperty=""

    if [ ${#ga_serverPropertiesArray[@]} -eq 0 ]; then
        printf "${red}serverPropertiesArray param is empty${nocolor}\n"
        SelectProperty_failed="true"
    else
        local arrayLength=${#ga_serverPropertiesArray[@]}
        local realArrayLenght=$((arrayLength-1))
        local tmp_array=()
        local cpt=0
        for value in "${!ga_serverPropertiesArray[@]}"; do # for array
            tmp_array+=("${value}")
        done


        IFS=$'\n' tmp_array_sorted=($(sort <<<"${tmp_array[*]}")); unset IFS
        # printf "[%s]\n" "${tmp_array_sorted[@]}"
        local cpt=0
        for value in "${tmp_array_sorted[@]}"; do # for print
            printf "${whiite}${cpt} ${graydim}> ${gray}%-8s${nocolor}\n" "${value}"
            cpt=$((cpt+1))
        done | column

        while true; do
            read -e -p "${promptTextColor}Select property ${promptTextColor2}0 - ${realArrayLenght}${promptNoColor} : " propertyIndex

            if [ -z "$propertyIndex" ]; then
                printf "${red}property index can't be empty${nocolor}\n"
                continue
            fi

            if ! [[ "$propertyIndex" =~ ^[0-9]+$ ]]; then # ^([0-9]+)[MG]$
                printf "${red}Index must be a number${nocolor}\n"
                continue
            fi

            if (( $propertyIndex < 0 || $propertyIndex >= $realArrayLenght )); then
                printf "${red}Index must be in range ${white}(1 - $realArrayLenght)${nocolor}\n"
                continue
            fi

            selectedProperty="${tmp_array_sorted[$propertyIndex]}"
            break
        done

        if [ -z "$selectedProperty" ]; then
            SelectProperty_failed="true"
        else
            if [ "$g_isVerboseActive" == "true" ] ; then
                printf "${gray}Selected property :${green} ${selectedProperty} ${nocolor}\n"
            fi
        fi
    fi
}

# @Function : Ask for value to assign to the property passed in param
# @Param : property name
# @Result : vars $propertyValue available
# @UseCase : 
# - AskForPropertyValue
# - if [ "$AskForPropertyValue_failed" == "true" ]; then echo "Property can't be edited" else echo "value assigned (retreive with $propertyValue)" fi
AskForPropertyValue () {
    AskForPropertyValue_failed="false"
    property=$1

    # test if param is empty
    if [ -z "$property" ]; then
        AskForPropertyValue_failed="true"

        if [ "$g_isVerboseActive" == "true" ] ; then
            printf "${red}property param is empty${nocolor} "
        fi
    else
        propertyValueType=${ga_serverPropertiesAllowValues[$property]}
        case $propertyValueType in
            boolean)
                printf "${gray}Actual value is :${whiite} ${ga_serverPropertiesArray[$property]} ${nocolor}\n"
                printf "${gray}"
                PS3='Select new value : '
                selectOpts=("true" "false")
                select opt in "${selectOpts[@]}"
                do
                    case $opt in
                        "true")
                            printf "${nocolor}"
                            propertyValue="true"
                            break
                            ;;
                        "false")
                            printf "${nocolor}"
                            propertyValue="false"
                            break
                            ;;
                        *) 
                            printf "${nocolor}"
                            printf "${red}invalid option $REPLY ${nocolor}"
                            continue
                        ;;
                    esac
                done
                
            ;;

            number)
                promptTextColor=$'\033[0;32m'
                promptNoColor=$'\033[0m'
                valueColor=$'\033[0;38;5;45m'

                printf "${gray}Actual value is :${valueColor} ${ga_serverPropertiesArray[$property]} ${nocolor}\n"
                while true; do
                    read -e -p "${promptNoColor}Select new numeric value : ${valueColor}" propertyValue
                    printf "${nocolor}"

                    if [ -z "$propertyValue" ]; then
                        printf "${red}Value can't be empty${nocolor}\n"
                        continue
                    else
                        re='^[0-9]+$'
                        if ! [[ $propertyValue =~ $re ]] ; then
                            printf "${orange}error: Not a number${nocolor}\n"
                            continue
                        fi
                    fi
                    break
                done
            ;;

            text)
                promptTextColor=$'\033[0;32m'
                promptNoColor=$'\033[0m'
                valueColor=$'\033[0;38;5;201m'

                printf "${gray}Actual value is :${valueColor} ${ga_serverPropertiesArray[$property]} ${nocolor}\n"
                while true; do
                    read -e -p read -e -p "${promptNoColor}Select new text value : ${valueColor}" propertyValue

                    if [ -z "$propertyValue" ]; then
                        printf "${red}Value can't be empty${nocolor}\n"
                        continue
                    fi
                    break
                done
            ;;

            dash-text)
                promptTextColor=$'\033[0;32m'
                promptNoColor=$'\033[0m'
                valueColor=$'\033[0;95m'

                printf "${gray}Actual value is :${valueColor} ${ga_serverPropertiesArray[$property]} ${nocolor}\n"
                while true; do
                    read -e -p read -e -p "${promptNoColor}Select new text (without space) value : ${valueColor}" propertyValue

                    if [ -z "$propertyValue" ]; then
                        printf "${red}Value can't be empty${nocolor}\n"
                        continue
                    else
                        propertyValue="${propertyValue// /-}"
                    fi
                    break
                done
            ;;
            
            array)
                printf "${gray}Actual value is :${green} ${ga_serverPropertiesArray[$property]} ${nocolor}\n"

                propertyValuesAsString=${ga_serverPropertiesAllowValuesList[$property]}
                IFS=' ' read -ra propertyValuesAsArray <<< "$propertyValuesAsString"

                printf "${gray}"
                PS3='Select new value in the list : '
                select opt in "${propertyValuesAsArray[@]}"; do
                    case "$opt" in
                        "") continue ;;
                        *)
                            printf "${nocolor}"
                            propertyValue=$opt
                            break
                            ;;
                    esac
                done
            ;;

            none)
                printf "${orange}property ${property} can't be edited\n${nocolor}"
                # break
                AskForPropertyValue_failed="true"
            ;;
        esac
        
        if [ "$AskForPropertyValue_failed" != "true" -a "$g_DoubleisVerboseActive" == "true" ] ; then
            printf "${gray}${property}=${blue}${propertyValue}${nocolor}\n"
        fi

    fi # endof if param is empty
}

# @Function : Ask list instances directories or screen sessions
# @Result : vars $useScreen available
# @UseCase : 
# - AskForServOrScreen
# - if [ "$useScreen" == "true" ]; then echo "list screens" else echo "list directories" fi
AskForServOrScreen () {
    #colors
    local promptTextColor=$'\033[0;32m'
    local promptTextColor2=$'\033[0;1;97m'
    local promptNoColor=$'\033[0m'
    local valueColor=$'\033[0;38;5;45m'
    
    useScreen="true"
    while true; do
        read -e -p "${promptNoColor}Use ${promptTextColor}Directories${promptNoColor} or ${promptTextColor}Screens${promptNoColor} (D/s) ? ${promptNoColor}" -i "d" dirOrScreen
        case $dirOrScreen in
            [Ss]* ) 
                useScreen="true"
                break
                ;;
            [Dd]* ) 
                useScreen="false"
                break
                ;;
            * ) printf "${red}Please answer s (screen) or d (directories).${nocolor}\n";;
        esac
    done
}





listServerScreen () {
    dirs=($g_serversDIR/*)

    for dir in "${dirs[@]}"; do
        if [ -d "$dir" ]; then
            dirbasename="$(basename -- $dir)"
            GetScreenInfoInline "mcserver.${dirbasename}"
            printf "${gray}$dirbasename${nocolor}\n"
            if [ "$inScreen" == "true" ]; then
                if [ "$cmdScreenStatus" == "Attached" ]; then
                  screenStatusColored="${green}attached${nocolor}"  
                elif [ "$cmdScreenStatus" == "Detached" ]; then
                    screenStatusColored="${yellow}detached${nocolor}"
                else
                    screenStatusColored="${blue}[ status not identified ]${nocolor}"
                fi
                screenStatusText="${gray}running ${screenStatusColored}${nocolor}"

                printf "${graydim}  Screen ${whiite}\"$cmdScreenName\" ${graydim}is ${screenStatusText} ${graydim}since ${gray}\"$cmdScreenDate\"${nocolor}\n"
            else
                printf "${graydim}  No screen found${nocolor}\n"
            fi
        fi
    done
}




##############
## COMMANDS ##
##############

cmd_ListAllServers () {

    listServerScreen
    # if [ ! -d "$g_serversDIR" ]; then
    #     printf "${orange} Directory $g_serversDIR not exists\n${nocolor}"
    #     CreateDir "$g_serversDIR"
    # else
    #     AskForServOrScreen
    #     if [ "$useScreen" == "true" ]; then
    #         ListScreenSessions
    #     else
    #         nb="$(ls "$g_serversDIR/" | wc -l)"
    #         if [ $nb -gt 0 ]; then
    #             printf "${green}  Minecraft servers :${whiite} ${nb} ${orange}(TODO: show running)${nocolor}\n"
    #             printf "${gray}"
    #             ls -ACDtu1 $g_serversDIR
    #             printf "${nocolor}"
    #         else
    #             printf "${yellow}  No minecraft servers\n${nocolor}"
    #             printf "${yellow}Use ${gray}${commandName} --create ${gray}to create one\n${nocolor}"
    #         fi
    #     fi
    # fi
}

cmd_ClearAllServers () {
    if [ ! -d "$g_serversDIR" ]; then
        printf "${orange} Directory $g_serversDIR not exists\n${nocolor}"
        CreateDir "$g_serversDIR"
    else
        AskForServOrScreen
        if [ "$useScreen" == "true" ]; then
            ClearDetachedScreens
        else
            nb="$(ls "$g_serversDIR/" | wc -l)"
            if [ $nb -gt 0 ]; then
                printf "${green}Theses servers will be removed :${nocolor}\n"
                ls -ACDtu1 $g_serversDIR
                printf "\n"
                read -e -p $'\033[0;38;5;178m  Are you sure ?\033[0m O/n : ' -i "n" clearValidation
                if [ "${clearValidation}" == "O" -o "${clearValidation}" == "o" ]; then
                    ClearDir "${g_serversDIR}"
                else
                    printf "${graydim}nothing done.${nocolor}\n"
                fi
            else
                printf "${yellow}  No minecraft servers\n${nocolor}"
                printf "${yellow}Use ${gray}${commandName} --create ${gray}to create one\n${nocolor}"
            fi
            printf "\n"
        fi
    fi
}

cmd_RemoveServer () {
    SelectServer
    if [ "$SelectServer_failed" == "false" ]; then 
        ClearDir "$g_serversDIR/$selectedServer"
    fi
}

cmd_CreateServer () {
    printf "\n${blue}Create a new server${nocolor}\n"
    AskForServerName "$1"
    local current_serverFullName=$serverFullName
    local current_serverName=$serverName

    SelectForVersion "$2"
    local current_version=$versionUsed

    local current_dirName="${current_serverName}.${current_version}"

    CheckExistingServer "${current_dirName}"
    if [ "$serverExists" == "true" ]; then 
        RenameServer "${current_dirName}"
    fi
    local serverDir="${g_serversDIR}/${current_dirName}"
    CreateDir "$serverDir"

    DownloadMinecraftServerVersion "${current_version}"
    if [ "$DownloadMinecraftServerVersion_failed" == "true" ]; then
        echo "error when download"
    else
        echo "download ok | file present"

        cp "${g_downloadDIR}/server.${versionUsed}.jar" "${serverDir}"
        
        # test if file just copied is present
        if [ ! -f "${serverDir}/server.${versionUsed}.jar" ]; then
            echo "file not copied"
        else
            echo "file copied"
            
            InitialiseServer "${current_dirName}" "$3"
            if [ "$InitialiseServer_failed" == "true" ]; then
                printf "${red}Create server ${gray}\"${current_serverFullName}\" ${graydim}(${current_serverName})${red} with version ${gray}\"${current_version}\"${red} failed${nocolor}\n"
            else 
                printf "${green}Server ${whiitebold}\"${current_serverFullName}\" ${graydim}(${current_serverName})${gray} with version ${whiitebold}\"${current_version}\"${green} create with success !${nocolor}\n"
                printf "${gray}You can start it with : ${whiitebold}${commandName} --start ${gray}or use ${whiite} ${commandName} --config${gray} to config properties of server${nocolor}\n"
            fi
        fi
    fi
}

cmd_StartServer () {
    printf "${green}Choose a server to start :${nocolor}\n"
    SelectServer 
    if [ "$SelectServer_failed" == "true" ]; then
        echo "server not found"
    else
        echo "server selected : $selectedServer"

        AskForMemory
        local memory=$memorySelected

        StartServer "${selectedServer}" "${memory}"
    fi
}

cmd_ConfigServer () {
    printf "${green}Choose a server to configure :${nocolor}\n"
    SelectServer 
    if [ "$SelectServer_failed" == "true" ]; then
        printf "${red}server not found${nocolor}\n"
    else
        # echo "server selected : $selectedServer"

        if [ ! -f "${g_serversDIR}/${selectedServer}/server.properties" ]; then
            printf "${red}No server.properties file found for server ${gray}${selectedServer} ${graydim}(${g_serversDIR}/${selectedServer}/server.properties)${nocolor}\n"
        else
            # LoadServerPropertiesFile "$propertyFile"
            # if [ "$LoadServerPropertiesFile_status" == "true" ]; then
            #     printf "${red}LoadServerPropertiesFile failed${nocolor}\n"
            # else
                # AskForConfigEdition
                # if [ "$editWithPrompt" == "true" ]; then 

                    printf "${whiite}Edit ${whiitebold}${selectedServer} ${gray}server.properties${nocolor}\n"

                    LoadServerPropertiesFile "$propertyFile"
                    if [ "$LoadServerPropertiesFile_status" == "true" ]; then
                        printf "${red}LoadServerPropertiesFile failed${nocolor}\n"
                    else
                        # SelectProperty
                        AskForProperty
                        if [ "$SelectProperty_failed" == "true" ]; then
                            printf "${red}Property empty${nocolor}\n"
                        else
                            AskForPropertyValue "${selectedProperty}"
                            if [ "$AskForPropertyValue_failed" == "true" ]; then
                                printf "${red}Property can't be edited${nocolor}\n"
                            else

                                if [[ -z $selectedProperty || -z $propertyValue ]]; then
                                    printf "${red}var that define array are empty${nocolor}\n"
                                else
                                    ga_serverPropertiesArray["${selectedProperty}"]="$propertyValue"

                                    ## update file
                                    UpdateServerPropertiesFile "${g_serversDIR}/${selectedServer}/server.properties"
                                    if [ "$updateServerPropertiesFile_failed" == "true" ]; then
                                        echo "server.properties file not found"
                                    else 
                                        printf "${gray}property ${green}$selectedProperty ${gray}update with value ${whiite}${propertyValue}${nocolor}\n"
                                        printf "${graydim}Use ${gray}${commandName} --start ${graydim}to start the server${nocolor}\n"
                                    fi
                                fi
                            fi
                        fi
                    fi
                # else
                #     printf "${graydim}use ${gray}nano${graydim} to edit${nocolor}\n"
                #     nano "${g_serversDIR}/${selectedServer}/server.properties"
                # fi
            # fi
        fi
    fi
}




##########
## HELPERS ##
##########

StartText () {
    printf "\n${blue}This script is made for generate a READY-TO-USE minecraft server.
Follow the next steps to deploy your server !${nocolor}\n"
}
HowToUse () {
    printf "${gray}
${commandName} [ -i | --install : download and install command ]
       [ --checkInstall : verify that command is installed ]
       [ --setGlobal    : set command usable globally ]
       [ --create       : create a server ]
       [ --config       : config a server ]
       [ -l | --list    : list all servers ]
       [ -s | --start   : start a server ]
       [ --connect      : connect to a server ]
       [ --remove       : choose a server to remove ]
       [ --clear        : clear all the instances (ls ${g_serversDIR}) ]
       [ -h | --help    : show this message ]
${graydim}See README.md for more explainations${nocolor}\n
"
}

#####
## START SCRIPT
#####
CheckForJavaInstall
if [ "$g_isJavaInstalled" == "false" ]; then
    exit 0;
fi

options=$(getopt -a -n ${commandName} -o ilsh --long install,checkInstall,setGlobal,create,config,list,start,connect,remove,clear,help -- "$@")
[ $? -eq 0 ] || { 
    printf "${red}Incorrect options provided${nocolor}\n"
    exit 1
}
eval set -- "$options"
while true; do
    case "$1" in
    -i | --install)
        if [ "$CheckIfCmdInstall" == "true" ]; then
            printf "${green}Server Manager is already installed${nocolor}\n"
        else
            InstallCmd
        fi
        break
        ;;
    --checkInstall)
        CheckCmdInstalled_explicit
        break
        ;;
    --setGlobal)
        InstallCmdGlobally
        break
        ;;
    --create)
        CheckCmdInstalled
        if [ "$CheckIfCmdInstall" == "true" ]; then
            cmd_CreateServer "$3" "$4" "$5"
        else
            printf "${red}No install found. use ${gray}${commandName} --install${nocolor} ${nocolor}\n"
        fi
        break
        ;;
    --config)
        CheckCmdInstalled
        if [ "$CheckIfCmdInstall" == "true" ]; then
            cmd_ConfigServer
        else
            printf "${red}No install found. use ${gray}${commandName} --install${nocolor} ${nocolor}\n"
        fi
        break
        ;;
    -l | --list)
        cmd_ListAllServers
        break
        ;;
    -s | --start)
        CheckCmdInstalled
        if [ "$CheckIfCmdInstall" == "true" ]; then
            printf "\n"
            cmd_StartServer
        else
            printf "${red}No install found. use ${gray}${commandName} --install${nocolor} ${nocolor}\n"
        fi
        break
        ;;
    --connect)
        SelectScreenSession
        if [ "$SelectForVersion_failed" == "true" ]; then
            printf "${whiite}\"srvcraft --list\"${gray} to list current screen sessions${nocolor}\n"
            printf "${whiite}\"srvcraft --start\"${gray} to start one${nocolor}\n"
        else 
            AttachToScreen "$screenUsed"
        fi
        break
        ;;
    --remove)
        cmd_RemoveServer
        break
        ;;
    --clear)
        cmd_ClearAllServers
        break
        ;;
    -h | --help)
        HowToUse
        break
        ;;
    --)
        StartText
        HowToUse
        CheckCmdInstalled
        if [ "$CheckIfCmdInstall" == "false" ]; then
            AskForInstall
        fi
        break
        ;;
    esac
    shift
done

exit 0;